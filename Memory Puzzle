### Memory Puzzle
import random, pygame, sys
from pygame.locals import *
FPS = 30
WINDOWWIDTH = 640
WINDOWHEIGHT = 480
REVEALSPEED = 8
BOXSIZE = 40
GAPSIZE = 10
BOARDWIDTH = 10
BOARDHEIGHT = 7
assert (BOARDWIDTH * BOARDHEIGHT) % 2 == 0, 'Board must have an even number of boxes for pairs of matches.'
XMARGIN = int((WINDOWWIDTH - (BOARDWIDTH * (BOXSIZE + GAPSIZE))) / 2)
YMARGIN = int((WINDOWHEIGHT - (BOARDHEIGHT * (BOXSIZE + GAPSIZE))) / 2)
# Colors
GRAY = (100, 100, 100)
NAVYBLUE = (60, 60, 100)
WHITE = (255, 255, 255)
RED = (255, 0, 0)
GREEN = (0, 102, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
ORANGE = (255, 128, 0)
PURPLE = (255, 0, 255)
CYAN = (0, 255, 255)
BGCOLOR = GREEN
LIGHTBGCOLOR = GRAY
BOXCOLOR = WHITE
HIGHLIGHTCOLOR = BLUE

ALLCOLORS = (RED, GREEN, BLUE, YELLOW, ORANGE, PURPLE, CYAN)
ALLLETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
assert len(ALLCOLORS) * len(ALLLETTERS) * 2 >= BOARDWIDTH * BOARDHEIGHT, "Board is too big for the number of shapes/colors defined."

# Time settings
gameTimeLimit = 180000  # 3 minutes in milliseconds
bonusTime = 40000  # 40 seconds bonus time

def getRandomizedBoard():
    icons = []
    for color in ALLCOLORS:
        for letter in ALLLETTERS:
            icons.append((letter, color))
    random.shuffle(icons)
    numIconsUsed = int(BOARDWIDTH * BOARDHEIGHT / 2)
    icons = icons[:numIconsUsed] * 2
    random.shuffle(icons)

    board = []
    for x in range(BOARDWIDTH):
        column = []
        for y in range(BOARDHEIGHT):
            column.append(icons[0])
            del icons[0]
        board.append(column)
    return board
def getLetterAndColor(board, boxx, boxy):
    return board[boxx][boxy][0], board[boxx][boxy][1]

def drawIcon(letter, color, boxx, boxy):
    quarter = int(BOXSIZE * 0.25)
    half = int(BOXSIZE * 0.5)
    left, top = leftTopCoordsOfBox(boxx, boxy)
    font = pygame.font.Font('freesansbold.ttf', 20)
    text = font.render(letter, True, color, BGCOLOR)
    textRect = text.get_rect()
    textRect.center = (left + half, top + half)
    DISPLAYSURF.blit(text, textRect)
def checkWord(board, revealed, word):
    foundWord = ''
    for x in range(BOARDWIDTH):
        for y in range(BOARDHEIGHT):
            if revealed[x][y]:
                foundWord += board[x][y][0]
    return word in foundWord

def drawTimer(timeRemaining):
    mins, secs = divmod(timeRemaining // 1000, 60)
    timeText = 'Time remaining: {:02}:{:02}'.format(mins, secs)
    font = pygame.font.Font(None, 36)
    text = font.render(timeText, True, WHITE)
    textRect = text.get_rect()
    textRect.topleft = (10, 10)
    DISPLAYSURF.blit(text, textRect)

def gameOverAnimation():
    font = pygame.font.Font(None, 48)
    text = font.render('Time\'s up!', True, RED)
    textRect = text.get_rect()
    textRect.center = (WINDOWWIDTH // 2, WINDOWHEIGHT // 2)
    DISPLAYSURF.blit(text, textRect)
    pygame.display.update()
def generateRevealedBoxesData(val):
    """
    This function creates a 2D list that keeps track of which boxes on the game board have been revealed.
    The "val" parameter is the initial value for each element in the list (typically False for not revealed, or True for revealed)
    """
    revealedBoxes = []
    for i in range(BOARDWIDTH):
        revealedBoxes.append([val] * BOARDHEIGHT) # creates a list with "val" repeated BOARDHEIGHT times, and appends it to the revealedBoxes list
    # returns the completed 2D list of revealed boxes
    return revealedBoxes

def startGameAnimation(board):
    # Randomly reveal the boxes 8 at a time.
    coveredBoxes = generateRevealedBoxesData(False)
    boxes = []
    for x in range(BOARDWIDTH):
        for y in range(BOARDHEIGHT):
            boxes.append( (x, y) )
    random.shuffle(boxes)
    boxGroups = splitIntoGroupsOf(8, boxes)
    #Draw the initial state of the game board with all boxes covered
    drawBoard(board, coveredBoxes) 
    #Iterate through each group of boxes and reveal them one group at a time with a slight delay between each group
    for boxGroup in boxGroups:
        revealBoxesAnimation(board, boxGroup)
        coverBoxesAnimation(board, boxGroup)
        
 def splitIntoGroupsOf(groupSize, theList):
    """
    This function takes in two parameters, groupSize and theList.
    It splits theList into a list of lists, where the inner lists have at most groupSize number of items.
    """
    result = [] #initialize an empty list to store the split lists
    for i in range(0, len(theList), groupSize):  #iterate over theList with a step of groupSize
        result.append(theList[i:i + groupSize]) #append a slice of theList from i to i+groupSize to the result list
    return result #return the final list of lists.

def drawBoard(board, revealed):
    # Iterate through each column (boxx) and row (boxy) on the game board
    for boxx in range(BOARDWIDTH):
        for boxy in range(BOARDHEIGHT):
            # Get the left and top pixel coordinates of the current box
            left, top = leftTopCoordsOfBox(boxx, boxy)
            if not revealed[boxx][boxy]:
                # If the box is not revealed, draw a covered box using the BOXCOLOR
                pygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, BOXSIZE, BOXSIZE))
            else:
                # If the box is revealed, draw the icon at that position using the shape and color from the board
                shape, color = getShapeAndColor(board, boxx, boxy)
                drawIcon(shape, color, boxx, boxy)
def drawHighlightBox(boxx, boxy):
    #Draws a highlighted border around the box at the given x and y coordinates on the board
    left, top = leftTopCoordsOfBox(boxx, boxy)
    # Draw a rectangle with a 4 pixel wide border, offset by 5 pixels from the box coordinates
    pygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, (left - 5, top - 5, BOXSIZE + 10, BOXSIZE + 10), 4)

def leftTopCoordsOfBox(boxx, boxy):
    """
    Convert board coordinates to pixel coordinates
    boxx: x-coordinate of the box on the board (column)
    boxy: y-coordinate of the box on the board (row)
    returns: a tuple containing the left and top pixel coordinates of the box
    """
    left = boxx * (BOXSIZE + GAPSIZE) + XMARGIN
    top = boxy * (BOXSIZE + GAPSIZE) + YMARGIN
    return (left, top)
def revealBoxesAnimation(board, boxesToReveal):
    # Do the "box reveal" animation.
    for coverage in range(BOXSIZE, (-REVEALSPEED) - 1, -REVEALSPEED):      # For each iteration, coverage decreases by REVEALSPEED. This causes the boxes to appear to slide open
        drawBoxCovers(board, boxesToReveal, coverage)  # Draw the boxes with the updated coverage value. This causes the boxes to appear to slide open

def drawBoxCovers(board, boxes, coverage):
    """
    Draws boxes being covered/revealed.
    board: the game board containing the icons
    boxes: a list of two-item lists, which have the x & y spot of the box.
    coverage: the amount of coverage for boxes, where 0 is fully revealed and BOXSIZE is fully covered
    """
    for box in boxes:
        left, top = leftTopCoordsOfBox(box[0], box[1])
        pygame.draw.rect(DISPLAYSURF, BGCOLOR, (left, top, BOXSIZE, BOXSIZE))
        shape, color = getShapeAndColor(board, box[0], box[1])
        drawIcon(shape, color, box[0], box[1])
        if coverage > 0: # only draw the cover if there is an coverage
            pygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, coverage, BOXSIZE))
    pygame.display.update()
    FPSCLOCK.tick(FPS)
def getShapeAndColor(board, boxx, boxy):
    """
    Given the game board, and x, y coordinates for a box,
    this function returns the shape and color of the icon in that box
    """
    return board[boxx][boxy][0], board[boxx][boxy][1]

def coverBoxesAnimation(board, boxesToCover):
    # Do the "box cover" animation.
    # Loop through a range of values, incrementing by the REVEALSPEED variable

    for coverage in range(0, BOXSIZE + REVEALSPEED, REVEALSPEED):
        drawBoxCovers(board, boxesToCover, coverage) #     # Draw the box covers with the current coverage level

def getBoxAtPixel(x, y):
    """
    Given x and y coordinates, this function returns the box number (in terms of
    column and row) that the coordinates belong to. If the coordinates do not belong
    to any box, it returns (None, None).
    """
    for boxx in range(BOARDWIDTH):
        for boxy in range(BOARDHEIGHT):
            left, top = leftTopCoordsOfBox(boxx, boxy)
            boxRect = pygame.Rect(left, top, BOXSIZE, BOXSIZE)
            if boxRect.collidepoint(x, y):
                return (boxx, boxy)
    return (None, None)
def main():
    global FPSCLOCK, DISPLAYSURF, startTime, timeRemaining
    pygame.init()
    FPSCLOCK = pygame.time.Clock()
    DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))

    mousex = 0
    mousey = 0
    pygame.display.set_caption('Memory Game')

    mainBoard = getRandomizedBoard()
    revealedBoxes = generateRevealedBoxesData(False)

    firstSelection = None
    DISPLAYSURF.fill(BGCOLOR)
    startGameAnimation(mainBoard)

    startTime = pygame.time.get_ticks()
    timeRemaining = gameTimeLimit

    while True:
        gameTimeElapsed = pygame.time.get_ticks() - startTime
        timeRemaining = gameTimeLimit - gameTimeElapsed if gameTimeElapsed < gameTimeLimit else 0

        if timeRemaining <= 0:
            gameOverAnimation()
            pygame.time.wait(2000)
            main()

        mouseClicked = False
        DISPLAYSURF.fill(BGCOLOR)
        drawBoard(mainBoard, revealedBoxes)
        drawTimer(timeRemaining)

        for event in pygame.event.get():
            if event.type == QUIT or (event.type == KEYUP and event.key == K_ESCAPE):
                pygame.quit()
                sys.exit()
            elif event.type == MOUSEMOTION:
                mousex, mousey = event.pos
            elif event.type == MOUSEBUTTONUP:
                mousex, mousey = event.pos
                mouseClicked = True

        boxx, boxy = getBoxAtPixel(mousex, mousey)
        if boxx != None and boxy != None:
            if not revealedBoxes[boxx][boxy]:
                drawHighlightBox(boxx, boxy)
            if not revealedBoxes[boxx][boxy] and mouseClicked:
                revealBoxesAnimation(mainBoard, [(boxx, boxy)])
                revealedBoxes[boxx][boxy] = True
                if firstSelection == None:
                    firstSelection = (boxx, boxy)
                else:
                    icon1letter, icon1color = getLetterAndColor(mainBoard, firstSelection[0], firstSelection[1])
                    icon2letter, icon2color = getLetterAndColor(mainBoard, boxx, boxy)

                    if icon1letter != icon2letter or icon1color != icon2color:
                        pygame.time.wait(1000)
                        coverBoxesAnimation(mainBoard, [(firstSelection[0], firstSelection[1]), (boxx, boxy)])
                        revealedBoxes[firstSelection[0]][firstSelection[1]] = False
                        revealedBoxes[boxx][boxy] = False
                    else:
                        if checkWord(mainBoard, revealedBoxes, 'APPLE'):
                            startTime += bonusTime  # Extend time if 'APPLE' is formed
                    firstSelection = None

        pygame.display.update()
        FPSCLOCK.tick(FPS)
if __name__ == '__main__':
    main()
