import pygame
import random
import sys

# Initialize Pygame
pygame.init()

# Set up display dimensions and title
SCREEN_WIDTH, SCREEN_HEIGHT = 800, 600
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Mini Arcade Games")

# Fonts and Colors
LETTER_FONT = pygame.font.SysFont('comicsans', 16)  # Adjusted font size
WORD_FONT = pygame.font.SysFont('comicsans', 32)    # Adjusted font size
TITLE_FONT = pygame.font.SysFont('comicsans', 40)   # Adjusted font size
BUTTON_FONT = pygame.font.SysFont('comicsans', 24)  # Adjusted font size
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
GRAY = (128, 128, 128)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)

# Hangman game variables
themes = {
    "Science": ["GRAVITY", "ATOM", "ENERGY", "QUANTUM", "NEURON"],
    "Sports": ["FOOTBALL", "BASKETBALL", "CRICKET", "TENNIS", "BASEBALL"],
    "Geography": ["MOUNTAIN", "RIVER", "COUNTRY", "CITY", "OCEAN"],
    "Animals": ["ELEPHANT", "GIRAFFE", "RHINOCEROS", "KANGAROO", "TIGER"]
}
words = []
word = ''
guessed = {}
hangman_status = 0

# Keyboard layout (QWERTZ)
keys = [
    "QWERTZUIOPÜ",
    "ASDFGHJKLÖÄ",
    "YXCVBNM"
]
key_positions = []

# Initialize the key positions for the virtual keyboard
def init_keys():
    global key_positions
    key_positions.clear()
    key_width = 40
    key_height = 40
    key_spacing = 10
    starting_y = 400
    for index, row in enumerate(keys):
        total_row_width = len(row) * (key_width + key_spacing) - key_spacing
        starting_x = (SCREEN_WIDTH - total_row_width) // 2
        for i, letter in enumerate(row):
            x = starting_x + i * (key_width + key_spacing)
            y = starting_y + index * (key_height + 10)
            key_positions.append((letter, x, y, key_width, key_height, WHITE))

# Draw the keys for the virtual keyboard
def draw_keys():
    for letter, x, y, width, height, color in key_positions:
        pygame.draw.rect(screen, color, (x, y, width, height))
        text = LETTER_FONT.render(letter, True, BLACK)
        screen.blit(text, (x + (width - text.get_width()) // 2, y + (height - text.get_height()) // 2))

# Draw the hangman figure based on the number of incorrect guesses
def draw_hangman():
    stages = [
        lambda: pygame.draw.circle(screen, WHITE, (650, 150), 30, 3),  # Head
        lambda: pygame.draw.line(screen, WHITE, (650, 180), (650, 250), 3),  # Body
        lambda: pygame.draw.line(screen, WHITE, (650, 200), (600, 230), 3),  # Left Arm
        lambda: pygame.draw.line(screen, WHITE, (650, 200), (700, 230), 3),  # Right Arm
        lambda: pygame.draw.line(screen, WHITE, (650, 250), (600, 300), 3),  # Left Leg
        lambda: pygame.draw.line(screen, WHITE, (650, 250), (700, 300), 3)  # Right Leg
    ]
    for i in range(hangman_status):
        stages[i]()

# Update the color of the keys based on the player's guesses
def update_keys(guess, correct):
    for i, (letter, x, y, width, height, color) in enumerate(key_positions):
        if letter == guess:
            key_positions[i] = (letter, x, y, width, height, GREEN if correct else RED)

# Draw the current state of the Hangman game
def draw(current_guess):
    screen.fill(BLACK)
    text = TITLE_FONT.render("HANGMAN", 1, WHITE)
    screen.blit(text, (SCREEN_WIDTH / 2 - text.get_width() / 2, 20))
    display_word = " ".join([letter if letter in guessed else '_' for letter in word])
    text = WORD_FONT.render(display_word, 1, WHITE)
    screen.blit(text, (SCREEN_WIDTH / 2 - text.get_width() / 2, 200))
    draw_keys()
    draw_hangman()
    draw_back_button()
    pygame.display.update()

# Display a message on the screen
def message_display(message):
    screen.fill(BLACK)  # Clear screen before displaying the message
    text = WORD_FONT.render(message, 1, WHITE)
    screen.blit(text, (SCREEN_WIDTH / 2 - text.get_width() / 2, SCREEN_HEIGHT / 2 - text.get_height() / 2))
    pygame.display.update()
    pygame.time.delay(2000)

# Display an end game message with options to restart, quit, or return to the main menu
def end_game_message(message):
    message_display(message)
    message_display("Press R to restart or Q to quit or B to go back to menu")
    wait_for_input()

# Wait for user input to either restart, quit, or return to the main menu
def wait_for_input():
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_r:
                    hangman_game()
                elif event.key == pygame.K_q:
                    pygame.quit()
                    sys.exit()
                elif event.key == pygame.K_b:
                    main_menu()

# Draw the theme buttons for the Hangman game
def draw_theme_buttons():
    global theme_buttons
    theme_buttons = [
        ("Science", 150, 250, 200, 50, WHITE),
        ("Sports", 450, 250, 200, 50, WHITE),
        ("Geography", 150, 350, 200, 50, WHITE),
        ("Animals", 450, 350, 200, 50, WHITE)
    ]
    for theme, x, y, width, height, color in theme_buttons:
        pygame.draw.rect(screen, color, (x, y, width, height))
        text = LETTER_FONT.render(theme, True, BLACK)
        screen.blit(text, (x + (width - text.get_width()) // 2, y + (height - text.get_height()) // 2))

# Allow the player to select a theme for the Hangman game
def theme_selection():
    screen.fill(BLACK)
    text = TITLE_FONT.render("Please select theme for your words", True, WHITE)
    screen.blit(text, (SCREEN_WIDTH // 2 - text.get_width() // 2, 150))
    draw_theme_buttons()
    draw_back_button()
    pygame.display.update()
    choosing = True
    while choosing:
        for event in pygame.event.get():
            if event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos
                for theme, tx, ty, twidth, theight, _ in theme_buttons:
                    if tx <= x <= tx + twidth and ty <= y <= ty + theight:
                        return theme
                if back_button.collidepoint(x, y):
                    main_menu()
            elif event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

# Main function for the Hangman game
def hangman_game():
    global words, word, guessed, hangman_status
    selected_theme = theme_selection()
    words = themes[selected_theme]
    word = random.choice(words).upper()
    guessed = {}
    hangman_status = 0
    init_keys()
    run = True
    clock = pygame.time.Clock()

    while run:
        clock.tick(30)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos
                if back_button.collidepoint(x, y):
                    main_menu()
                for letter, kx, ky, kwidth, kheight, kcolor in key_positions:
                    if kx <= x <= kx + kwidth and ky <= y <= ky + kheight:
                        if letter not in guessed:
                            guessed[letter] = letter in word
                            update_keys(letter, guessed[letter])
                            if not guessed[letter]:
                                hangman_status += 1
                            if hangman_status == 6:
                                end_game_message(f"You LOST! Word was: {word}")
                                run = False
                            elif all(letter in guessed for letter in word):
                                end_game_message("You WON! Congrats!")
                                run = False
                            break

        if run:
            draw("")

# Snake Game Code
WINDOW_WIDTH, WINDOW_HEIGHT = 800, 600  # Set same dimensions as the main menu
INITIAL_SNAKE_SPEED = 10
BLOCK_SIZE = 10
COLORS = {
    "black": pygame.Color(0, 0, 0),
    "white": pygame.Color(255, 255, 255),
    "red": pygame.Color(255, 0, 0),
    "green": pygame.Color(0, 255, 0),
    "blue": pygame.Color(0, 0, 255),
    "yellow": pygame.Color(255, 255, 0),
    "grey": pygame.Color(128, 128, 128),
}

# Class for game components (snake body parts, fruit, obstacles)
class GameComponent:
    def __init__(self, position, color):
        self.position = position
        self.color = color

    def draw(self, game_window):
        pygame.draw.rect(game_window, self.color, pygame.Rect(
            self.position[0], self.position[1], BLOCK_SIZE, BLOCK_SIZE))

# Snake class
class Snake:
    def __init__(self, positions):
        self.body = [GameComponent(pos, COLORS["green"]) for pos in positions]
        self.direction = 'RIGHT'
        self.next_direction = 'RIGHT'

    def move(self):
        head_x, head_y = self.body[0].position
        if self.next_direction == 'UP':
            head_y -= BLOCK_SIZE
        elif self.next_direction == 'DOWN':
            head_y += BLOCK_SIZE
        elif self.next_direction == 'LEFT':
            head_x -= BLOCK_SIZE
        elif self.next_direction == 'RIGHT':
            head_x += BLOCK_SIZE
        new_head = GameComponent([head_x, head_y], COLORS["green"])
        self.body.insert(0, new_head)
        self.body.pop()

    def grow(self):
        tail_x, tail_y = self.body[-1].position
        self.body.append(GameComponent([tail_x, tail_y], COLORS["green"]))

    def check_collision(self, other):
        head_x, head_y = self.body[0].position
        return head_x == other.position[0] and head_y == other.position[1]

    def check_self_collision(self):
        head_x, head_y = self.body[0].position
        return any(head_x == part.position[0] and head_y == part.position[1] for part in self.body[1:])

    def draw(self, game_window):
        for part in self.body:
            part.draw(game_window)

# Fruit class
class Fruit:
    def __init__(self):
        self.position = [random.randrange(1, (WINDOW_WIDTH // BLOCK_SIZE)) * BLOCK_SIZE,
                         random.randrange(1, (WINDOW_HEIGHT // BLOCK_SIZE)) * BLOCK_SIZE]
        self.color = random.choice([COLORS["red"], COLORS["blue"], COLORS["yellow"]])
        self.points = 10 if self.color == COLORS["red"] else 15 if self.color == COLORS["blue"] else 20

    def respawn(self):
        self.position = [random.randrange(1, (WINDOW_WIDTH // BLOCK_SIZE)) * BLOCK_SIZE,
                         random.randrange(1, (WINDOW_HEIGHT // BLOCK_SIZE)) * BLOCK_SIZE]
        self.color = random.choice([COLORS["red"], COLORS["blue"], COLORS["yellow"]])
        self.points = 10 if self.color == COLORS["red"] else 15 if self.color == COLORS["blue"] else 20

    def draw(self, game_window):
        pygame.draw.rect(game_window, self.color, pygame.Rect(
            self.position[0], self.position[1], BLOCK_SIZE, BLOCK_SIZE))

# Obstacle class
class Obstacle:
    def __init__(self, number):
        self.obstacles = []
        for _ in range(number):
            x = random.randrange(1, (WINDOW_WIDTH // BLOCK_SIZE)) * BLOCK_SIZE
            y = random.randrange(1, (WINDOW_HEIGHT // BLOCK_SIZE)) * BLOCK_SIZE
            self.obstacles.append(GameComponent([x, y], COLORS["grey"]))

    def draw(self, game_window):
        for obstacle in self.obstacles:
            obstacle.draw(game_window)

# Main function for the Snake game
def snake_game():
    snake = Snake([[100 - i * BLOCK_SIZE, 50] for i in range(4)])
    fruit = Fruit()
    obstacles = Obstacle(5)
    score = 0
    level = 1
    speed = INITIAL_SNAKE_SPEED
    game_over = False
    clock = pygame.time.Clock()

    running = True
    while running:
        if not game_over:
            screen.fill(COLORS['black'])

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_UP and snake.direction != 'DOWN':
                        snake.next_direction = 'UP'
                    elif event.key == pygame.K_DOWN and snake.direction != 'UP':
                        snake.next_direction = 'DOWN'
                    elif event.key == pygame.K_LEFT and snake.direction != 'RIGHT':
                        snake.next_direction = 'LEFT'
                    elif event.key == pygame.K_RIGHT and snake.direction != 'LEFT':
                        snake.next_direction = 'RIGHT'

            snake.direction = snake.next_direction
            snake.move()

            if snake.check_collision(GameComponent(fruit.position, fruit.color)):
                score += fruit.points
                fruit.respawn()
                snake.grow()
                if score >= level * 100:
                    level += 1
                    speed = min(25, speed + 1)
                    obstacles = Obstacle(5 + 2 * level)

            if snake.check_self_collision() or \
               snake.body[0].position[0] < 0 or snake.body[0].position[0] >= WINDOW_WIDTH or \
               snake.body[0].position[1] < 0 or snake.body[0].position[1] >= WINDOW_HEIGHT:
                game_over = True

            for obstacle in obstacles.obstacles:
                if snake.check_collision(obstacle):
                    game_over = True

            snake.draw(screen)
            fruit.draw(screen)
            obstacles.draw(screen)

            font = pygame.font.SysFont('times new roman', 12)  # Adjusted font size
            score_surf = font.render(f'Score: {score} Level: {level}', True, COLORS['white'])
            screen.blit(score_surf, (5, 5))

            pygame.display.update()
            clock.tick(speed)
        else:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_r:
                        snake_game()
                    elif event.key == pygame.K_q:
                        running = False
                    elif event.key == pygame.K_b:
                        main_menu()
            
            screen.fill(COLORS['black'])
            font_big = pygame.font.SysFont('times new roman', 20)  # Adjusted font size
            game_over_surf = font_big.render('Game Over', True, COLORS['red'])
            restart_surf = font_big.render('Press R to Restart or Q to Quit or B to go back to menu', True, COLORS['white'])
            score_surf = font_big.render(f'Final Score: {score}', True, COLORS['yellow'])

            screen.blit(game_over_surf, (WINDOW_WIDTH / 2 - game_over_surf.get_width() / 2, WINDOW_HEIGHT / 2 - game_over_surf.get_height() / 2 - 20))
            screen.blit(score_surf, (WINDOW_WIDTH / 2 - score_surf.get_width() / 2, WINDOW_HEIGHT / 2 + 20))
            screen.blit(restart_surf, (WINDOW_WIDTH / 2 - restart_surf.get_width() / 2, WINDOW_HEIGHT / 2 + 60))

            pygame.display.update()

# Back button
back_button = pygame.Rect(10, 10, 100, 50)

# Draw the back button
def draw_back_button():
    pygame.draw.rect(screen, GRAY, back_button)
    text = BUTTON_FONT.render("Back", True, BLACK)
    screen.blit(text, (back_button.x + (back_button.width - text.get_width()) // 2, back_button.y + (back_button.height - text.get_height()) // 2))

# Minesweeper game constants
MINESWEEPER_GRID_SIZE = 10
CELL_SIZE = 50
NUM_MINES = 20
MINESWEEPER_WINDOW_WIDTH, MINESWEEPER_WINDOW_HEIGHT = SCREEN_WIDTH, SCREEN_HEIGHT

# Minesweeper colors
MINESWEEPER_COLORS = {
    "white": pygame.Color(239, 235, 235),
    "black": pygame.Color(29, 31, 32),
    "red": pygame.Color(163, 72, 53),
    "grey": pygame.Color(225, 225, 225),
    "dark_grey": pygame.Color(42, 44, 51),
    "green": pygame.Color(162, 173, 159)
}

# Minesweeper Cell class
class MinesweeperCell:
    def __init__(self, x, y):
        self.is_mine = False
        self.revealed = False
        self.flagged = False
        self.x = x
        self.y = y
        self.adjacent_mines = 0

    def draw(self, game_window):
        rect = pygame.Rect(self.x * CELL_SIZE, self.y * CELL_SIZE, CELL_SIZE, CELL_SIZE)
        if self.revealed:
            if self.is_mine:
                pygame.draw.rect(game_window, MINESWEEPER_COLORS["red"], rect)
            else:
                pygame.draw.rect(game_window, MINESWEEPER_COLORS["grey"], rect)
                if self.adjacent_mines > 0:
                    font = pygame.font.SysFont('arial', 24)  # Adjusted font size
                    text = font.render(str(self.adjacent_mines), True, MINESWEEPER_COLORS["black"])
                    text_rect = text.get_rect(center=rect.center)
                    game_window.blit(text, text_rect)
        else:
            pygame.draw.rect(game_window, MINESWEEPER_COLORS["dark_grey"], rect)
            if self.flagged:
                font = pygame.font.SysFont('arial', 18)  # Adjusted font size
                text = font.render('F', True, MINESWEEPER_COLORS["green"])
                text_rect = text.get_rect(center=rect.center)
                game_window.blit(text, text_rect)
        pygame.draw.rect(game_window, MINESWEEPER_COLORS["white"], rect, 1)

# Create the Minesweeper grid
def create_minesweeper_grid():
    grid = [[MinesweeperCell(x, y) for y in range(MINESWEEPER_GRID_SIZE)] for x in range(MINESWEEPER_GRID_SIZE)]
    mine_locations = set()
    while len(mine_locations) < NUM_MINES:
        mine_locations.add((random.randint(0, MINESWEEPER_GRID_SIZE - 1), random.randint(0, MINESWEEPER_GRID_SIZE - 1)))
    for (x, y) in mine_locations:
        grid[x][y].is_mine = True
    for x in range(MINESWEEPER_GRID_SIZE):
        for y in range(MINESWEEPER_GRID_SIZE):
            if not grid[x][y].is_mine:
                grid[x][y].adjacent_mines = sum(
                    1 for dx in (-1, 0, 1) for dy in (-1, 0, 1) if 0 <= x + dx < MINESWEEPER_GRID_SIZE and 0 <= y + dy < MINESWEEPER_GRID_SIZE and grid[x + dx][y + dy].is_mine)
    return grid

# Main function for the Minesweeper game
def minesweeper_game():
    grid = create_minesweeper_grid()
    running = True
    game_over = False
    clock = pygame.time.Clock()

    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and not game_over:
                x, y = event.pos[0] // CELL_SIZE, event.pos[1] // CELL_SIZE
                if event.button == 1:
                    if not grid[x][y].flagged:
                        grid[x][y].revealed = True
                        if grid[x][y].is_mine:
                            game_over = True
                elif event.button == 3:
                    grid[x][y].flagged = not grid[x][y].flagged

        screen.fill(MINESWEEPER_COLORS["black"])
        for row in grid:
            for cell in row:
                cell.draw(screen)

        if game_over:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_r:
                        minesweeper_game()
                    elif event.key == pygame.K_q:
                        pygame.quit()
                        sys.exit()
                    elif event.key == pygame.K_b:
                        main_menu()

            screen.fill(MINESWEEPER_COLORS['black'])
            font_big = pygame.font.SysFont('times new roman', 20)  # Adjusted font size
            game_over_surf = font_big.render('Game Over', True, MINESWEEPER_COLORS['red'])
            restart_surf = font_big.render('Press R to Restart or Q to Quit or B to go back to menu', True, MINESWEEPER_COLORS['white'])

            screen.blit(game_over_surf, (SCREEN_WIDTH / 2 - game_over_surf.get_width() / 2, SCREEN_HEIGHT / 2 - game_over_surf.get_height() / 2 - 20))
            screen.blit(restart_surf, (SCREEN_WIDTH / 2 - restart_surf.get_width() / 2, SCREEN_HEIGHT / 2 + 20))

        pygame.display.flip()
        clock.tick(60)

# Memory Puzzle game constants
FPS = 30
REVEALSPEED = 8
BOXSIZE = 40
GAPSIZE = 10
BOARDWIDTH = 5
BOARDHEIGHT = 4
assert (BOARDWIDTH * BOARDHEIGHT) % 2 == 0, 'Board must have an even number of boxes for pairs of matches.'

XMARGIN = int((SCREEN_WIDTH - (BOARDWIDTH * (BOXSIZE + GAPSIZE))) / 2)
YMARGIN = int((SCREEN_HEIGHT - (BOARDHEIGHT * (BOXSIZE + GAPSIZE))) / 2)

# Colors
BGCOLOR = BLACK
LIGHTBGCOLOR = GRAY
BOXCOLOR = WHITE
HIGHLIGHTCOLOR = BLUE

# Memory Puzzle themes
memory_themes = {
    'default': {'colors': (RED, GREEN, BLUE, YELLOW), 'letters': 'AEFGHILP', 'bonusWord': 'APPLE'},
    'animals': {'colors': (RED, GREEN, BLUE, YELLOW), 'letters': 'CATTIGDOG', 'bonusWord': 'CAT'},
    'space': {'colors': (RED, GREEN, BLUE, YELLOW), 'letters': 'STARMOON', 'bonusWord': 'DOG'}
}

# Select theme for Memory Puzzle
def selectMemoryTheme(theme):
    global ALLCOLORS, ALLLETTERS, bonusWord
    ALLCOLORS = memory_themes[theme]['colors']
    ALLLETTERS = memory_themes[theme]['letters']
    bonusWord = memory_themes[theme]['bonusWord']

# Initialize the theme
currentMemoryTheme = 'default'
selectMemoryTheme(currentMemoryTheme)
assert len(ALLCOLORS) * len(ALLLETTERS) * 2 >= BOARDWIDTH * BOARDHEIGHT, "Board is too big for the number of shapes/colors defined."

# Time settings
gameTimeLimit = 180000  # 3 minutes in milliseconds
bonusTime = 40000  # 40 seconds bonus time

# Draw the Memory Puzzle board
def drawMemoryBoard(board, revealed):
    for boxx in range(BOARDWIDTH):
        for boxy in range(BOARDHEIGHT):
            left, top = leftTopCoordsOfBox(boxx, boxy)
            if not revealed[boxx][boxy]:
                pygame.draw.rect(screen, BOXCOLOR, (left, top, BOXSIZE, BOXSIZE))
            else:
                letter, color = getLetterAndColor(board, boxx, boxy)
                drawIcon(letter, color, boxx, boxy)

# Get a randomized board for Memory Puzzle
def getRandomizedBoard():
    icons = [(letter, color) for color in ALLCOLORS for letter in ALLLETTERS]
    random.shuffle(icons)
    numIconsUsed = int(BOARDWIDTH * BOARDHEIGHT / 2)
    icons = icons[:numIconsUsed] * 2
    random.shuffle(icons)

    board = []
    for x in range(BOARDWIDTH):
        column = []
        for y in range(BOARDHEIGHT):
            column.append(icons.pop(0))
        board.append(column)
    return board

# Get the letter and color of a box
def getLetterAndColor(board, boxx, boxy):
    return board[boxx][boxy]

# Draw an icon (letter) on the Memory Puzzle board
def drawIcon(letter, color, boxx, boxy):
    half = BOXSIZE // 2
    left, top = leftTopCoordsOfBox(boxx, boxy)
    font = pygame.font.Font('freesansbold.ttf', 20)
    text = font.render(letter, True, color, BGCOLOR)
    textRect = text.get_rect()
    textRect.center = (left + half, top + half)
    screen.blit(text, textRect)

# Check if the revealed boxes contain the bonus word
def checkWord(board, revealed, word):
    foundWord = ''.join(board[x][y][0] for x in range(BOARDWIDTH) for y in range(BOARDHEIGHT) if revealed[x][y])
    return word in foundWord

# Draw the remaining time
def drawTimer(timeRemaining):
    mins, secs = divmod(timeRemaining // 1000, 60)
    timeText = f'Time remaining: {mins:02}:{secs:02}'
    font = pygame.font.Font(None, 36)
    text = font.render(timeText, True, WHITE)
    textRect = text.get_rect()
    textRect.topleft = (10, 10)
    screen.blit(text, textRect)

# Display the game over animation for Memory Puzzle
def gameOverAnimation():
    font = pygame.font.Font(None, 48)
    text = font.render("Time's up!", True, RED)
    textRect = text.get_rect()
    textRect.center = (SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
    screen.blit(text, textRect)
    pygame.display.update()
    pygame.time.wait(2000)

    screen.fill(BGCOLOR)
    font_big = pygame.font.SysFont('times new roman', 20)  # Adjusted font size
    game_over_surf = font_big.render('Game Over', True, RED)
    restart_surf = font_big.render('Press R to Restart or Q to Quit or B to go back to menu', True, WHITE)

    screen.blit(game_over_surf, (SCREEN_WIDTH / 2 - game_over_surf.get_width() / 2, SCREEN_HEIGHT / 2 - game_over_surf.get_height() / 2 - 20))
    screen.blit(restart_surf, (SCREEN_WIDTH / 2 - restart_surf.get_width() / 2, SCREEN_HEIGHT / 2 + 20))

    pygame.display.update()

    wait_for_input_memory_game()

# Wait for user input to restart, quit, or go back to the main menu in Memory Puzzle
def wait_for_input_memory_game():
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_r:
                    memory_game()
                elif event.key == pygame.K_q:
                    pygame.quit()
                    sys.exit()
                elif event.key == pygame.K_b:
                    main_menu()

# Generate the initial revealed boxes data
def generateRevealedBoxesData(val):
    return [[val] * BOARDHEIGHT for _ in range(BOARDWIDTH)]

# Start the game animation for Memory Puzzle
def startGameAnimation(board):
    coveredBoxes = generateRevealedBoxesData(False)
    boxes = [(x, y) for x in range(BOARDWIDTH) for y in range(BOARDHEIGHT)]
    random.shuffle(boxes)
    boxGroups = splitIntoGroupsOf(8, boxes)
    drawMemoryBoard(board, coveredBoxes)
    for boxGroup in boxGroups:
        revealBoxesAnimation(board, boxGroup)
        coverBoxesAnimation(board, boxGroup)

# Display the game won animation for Memory Puzzle
def gameWonAnimation(board):
    coveredBoxes = generateRevealedBoxesData(True)
    color1 = LIGHTBGCOLOR
    color2 = BGCOLOR
    for _ in range(13):
        color1, color2 = color2, color1
        screen.fill(color1)
        drawMemoryBoard(board, coveredBoxes)
        pygame.display.update()
        pygame.time.wait(300)

# Check if the player has won the Memory Puzzle game
def hasWon(revealedBoxes):
    return all(all(row) for row in revealedBoxes)

# Display a celebration animation for Memory Puzzle
def celebrationAnimation():
    colors = [RED, GREEN, BLUE, YELLOW]
    for _ in range(60):
        screen.fill(BGCOLOR)
        for _ in range(20):
            pygame.draw.circle(screen, random.choice(colors), (random.randint(0, SCREEN_WIDTH), random.randint(0, SCREEN_HEIGHT)), random.randint(10, 40))
        pygame.display.update()
        pygame.time.wait(50)

# Split the list into groups of a specified size
def splitIntoGroupsOf(groupSize, theList):
    return [theList[i:i + groupSize] for i in range(0, len(theList), groupSize)]

# Draw a highlight box around the selected box
def drawHighlightBox(boxx, boxy):
    left, top = leftTopCoordsOfBox(boxx, boxy)
    pygame.draw.rect(screen, HIGHLIGHTCOLOR, (left - 5, top - 5, BOXSIZE + 10, BOXSIZE + 10), 4)

# Get the left and top coordinates of a box
def leftTopCoordsOfBox(boxx, boxy):
    left = boxx * (BOXSIZE + GAPSIZE) + XMARGIN
    top = boxy * (BOXSIZE + GAPSIZE) + YMARGIN
    return (left, top)

# Reveal the boxes animation for Memory Puzzle
def revealBoxesAnimation(board, boxesToReveal):
    for coverage in range(BOXSIZE, -REVEALSPEED - 1, -REVEALSPEED):
        drawBoxCovers(board, boxesToReveal, coverage)

# Draw the box covers for Memory Puzzle
def drawBoxCovers(board, boxes, coverage):
    for box in boxes:
        left, top = leftTopCoordsOfBox(box[0], box[1])
        pygame.draw.rect(screen, BGCOLOR, (left, top, BOXSIZE, BOXSIZE))
        letter, color = getLetterAndColor(board, box[0], box[1])
        drawIcon(letter, color, box[0], box[1])
        if coverage > 0:
            pygame.draw.rect(screen, BOXCOLOR, (left, top, coverage, BOXSIZE))
    pygame.display.update()
    FPSCLOCK.tick(FPS)

# Cover the boxes animation for Memory Puzzle
def coverBoxesAnimation(board, boxesToCover):
    for coverage in range(0, BOXSIZE + REVEALSPEED, REVEALSPEED):
        drawBoxCovers(board, boxesToCover, coverage)

# Get the box at a specific pixel
def getBoxAtPixel(x, y):
    for boxx in range(BOARDWIDTH):
        for boxy in range(BOARDHEIGHT):
            left, top = leftTopCoordsOfBox(boxx, boxy)
            boxRect = pygame.Rect(left, top, BOXSIZE, BOXSIZE)
            if boxRect.collidepoint(x, y):
                return (boxx, boxy)
    return (None, None)

# Increase the board size for Memory Puzzle
def increaseBoardSize():
    global BOARDWIDTH, BOARDHEIGHT, XMARGIN, YMARGIN, gameTimeLimit
    if BOARDWIDTH < 10 and BOARDHEIGHT < 10:  # Max size limit
        BOARDWIDTH += 1
        BOARDHEIGHT += 1
        XMARGIN = int((SCREEN_WIDTH - (BOARDWIDTH * (BOXSIZE + GAPSIZE))) / 2)
        YMARGIN = int((SCREEN_HEIGHT - (BOARDHEIGHT * (BOXSIZE + GAPSIZE))) / 2)
        gameTimeLimit += 60000  # Add 1 minute for each level

# Main function for the Memory Puzzle game
def memory_game():
    global FPSCLOCK, screen, startTime, timeRemaining
    FPSCLOCK = pygame.time.Clock()
    mousex = 0
    mousey = 0
    pygame.display.set_caption('Memory Game')

    # Allow the player to select a theme at the beginning of the game
    selectMemoryThemeMenu()

    mainBoard = getRandomizedBoard()
    revealedBoxes = generateRevealedBoxesData(False)

    firstSelection = None
    screen.fill(BGCOLOR)
    startGameAnimation(mainBoard)

    startTime = pygame.time.get_ticks()
    timeRemaining = gameTimeLimit

    while True:
        gameTimeElapsed = pygame.time.get_ticks() - startTime
        timeRemaining = gameTimeLimit - gameTimeElapsed if gameTimeElapsed < gameTimeLimit else 0

        if timeRemaining <= 0:
            gameOverAnimation()
            return

        mouseClicked = False
        screen.fill(BGCOLOR)
        drawMemoryBoard(mainBoard, revealedBoxes)
        drawTimer(timeRemaining)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEMOTION:
                mousex, mousey = event.pos
            elif event.type == pygame.MOUSEBUTTONUP:
                mousex, mousey = event.pos
                mouseClicked = True

        boxx, boxy = getBoxAtPixel(mousex, mousey)
        if boxx is not None and boxy is not None:
            if not revealedBoxes[boxx][boxy]:
                drawHighlightBox(boxx, boxy)
            if not revealedBoxes[boxx][boxy] and mouseClicked:
                revealBoxesAnimation(mainBoard, [(boxx, boxy)])
                revealedBoxes[boxx][boxy] = True
                if firstSelection is None:
                    firstSelection = (boxx, boxy)
                else:
                    icon1letter, icon1color = getLetterAndColor(mainBoard, firstSelection[0], firstSelection[1])
                    icon2letter, icon2color = getLetterAndColor(mainBoard, boxx, boxy)

                    if icon1letter != icon2letter or icon1color != icon2color:
                        pygame.time.wait(1000)
                        coverBoxesAnimation(mainBoard, [(firstSelection[0], firstSelection[1]), (boxx, boxy)])
                        revealedBoxes[firstSelection[0]][firstSelection[1]] = False
                        revealedBoxes[boxx][boxy] = False
                    else:
                        if checkWord(mainBoard, revealedBoxes, bonusWord):
                            startTime += bonusTime

                        if hasWon(revealedBoxes):
                            celebrationAnimation()
                            pygame.time.wait(2000)
                            increaseBoardSize()
                            startTime = pygame.time.get_ticks()
                            mainBoard = getRandomizedBoard()
                            revealedBoxes = generateRevealedBoxesData(False)
                            startGameAnimation(mainBoard)

                    firstSelection = None

        pygame.display.update()
        FPSCLOCK.tick(FPS)

# Theme selection menu for Memory Puzzle
def selectMemoryThemeMenu():
    global currentMemoryTheme
    while True:
        screen.fill(BGCOLOR)
        font = pygame.font.Font(None, 36)
        text = font.render('Select Theme:', True, WHITE)
        textRect = text.get_rect()
        textRect.center = (SCREEN_WIDTH // 2, SCREEN_HEIGHT // 4)
        screen.blit(text, textRect)

        themeOptions = list(memory_themes.keys())
        for i, theme in enumerate(themeOptions):
            themeText = font.render(theme.capitalize(), True, WHITE)
            themeRect = themeText.get_rect()
            themeRect.center = (SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + i * 40)
            screen.blit(themeText, themeRect)

        pygame.display.update()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONUP:
                mousex, mousey = event.pos
                for i, theme in enumerate(themeOptions):
                    themeRect = pygame.Rect(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + i * 40 - 20, 100, 40)
                    if themeRect.collidepoint(mousex, mousey):
                        currentMemoryTheme = theme
                        selectMemoryTheme(theme)
                        return

# Main menu for the mini arcade collection
def main_menu():
    run = True
    while run:
        screen.fill(BLACK)
        title_text = TITLE_FONT.render("Mini Arcade Games", True, WHITE)
        screen.blit(title_text, (SCREEN_WIDTH // 2 - title_text.get_width() // 2, 100))
        
        hangman_button = pygame.Rect(30, 300, 140, 100)
        snake_button = pygame.Rect(200, 300, 140, 100)
        minesweeper_button = pygame.Rect(370, 300, 140, 100)
        memory_button = pygame.Rect(540, 300, 140, 100)
        
        pygame.draw.rect(screen, GRAY, hangman_button)
        pygame.draw.rect(screen, GRAY, snake_button)
        pygame.draw.rect(screen, GRAY, minesweeper_button)
        pygame.draw.rect(screen, GRAY, memory_button)
        
        hangman_text = BUTTON_FONT.render("Hangman", True, BLACK)
        snake_text = BUTTON_FONT.render("Snake", True, BLACK)
        minesweeper_text = BUTTON_FONT.render("Minesweeper", True, BLACK)
        memory_text = BUTTON_FONT.render("Memory", True, BLACK)
        
        screen.blit(hangman_text, (hangman_button.x + (hangman_button.width - hangman_text.get_width()) // 2, hangman_button.y + (hangman_button.height - hangman_text.get_height()) // 2))
        screen.blit(snake_text, (snake_button.x + (snake_button.width - snake_text.get_width()) // 2, snake_button.y + (snake_button.height - snake_text.get_height()) // 2))
        screen.blit(minesweeper_text, (minesweeper_button.x + (minesweeper_button.width - minesweeper_text.get_width()) // 2, minesweeper_button.y + (minesweeper_button.height - minesweeper_text.get_height()) // 2))
        screen.blit(memory_text, (memory_button.x + (memory_button.width - memory_text.get_width()) // 2, memory_button.y + (memory_button.height - memory_text.get_height()) // 2))
        
        pygame.display.update()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                mousex, mousey = event.pos
                if hangman_button.collidepoint(mousex, mousey):
                    hangman_game()
                elif snake_button.collidepoint(mousex, mousey):
                    snake_game()
                elif minesweeper_button.collidepoint(mousex, mousey):
                    minesweeper_game()
                elif memory_button.collidepoint(mousex, mousey):
                    memory_game()

if __name__ == "__main__":
    main_menu()
    pygame.quit()
    sys.exit() 
