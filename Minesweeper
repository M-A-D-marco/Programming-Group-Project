### Minesweeper

# import the pygame module
import pygame

import random
import sys

# Define constants for the game
GRID_SIZE = 10 # Number of cells in each row and column
CELL_SIZE = 50 # Pixel size of each cell
NUM_MINES = 20 # Total number of mines to place on the grid
WINDOW_WIDTH, WINDOW_HEIGHT = GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE

# Define colors
COLORS = {
    "white": pygame.Color(239, 235, 235),
    "black": pygame.Color(29, 31, 32),
    "red": pygame.Color(163, 72, 53),
    "grey": pygame.Color(225, 225, 225),
    "dark_grey": pygame.Color(42, 44, 51),
    "green": pygame.Color(162, 173, 159)
}

# Initialize pygame module
pygame.init()
# Create a surface on screen that has the size of WINDOW_WIDTH x WINDOW_HEIGHT
game_window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
# Set Caption to Minesweeper
pygame.display.set_caption('Minesweeper')
# Create an object to help track time
clock = pygame.time.Clock()

# Class to manage cells and mines
class Cell:
    def __init__(self, x, y): # Constructor initializes cell properties
        self.is_mine = False
        self.revealed = False
        self.flagged = False
        self.x = x
        self.y = y
        self.adjacent_mines = 0

    def draw(self): # Draws each cell based on its state (revealed, flagged, mine)
        # Define rectangle for cell
        rect = pygame.Rect(self.x * CELL_SIZE, self.y * CELL_SIZE, CELL_SIZE, CELL_SIZE)
        if self.revealed:
            if self.is_mine:
                # Draw mine
                pygame.draw.rect(game_window, COLORS["red"], rect)
            else:
                # Draw revealed cell
                pygame.draw.rect(game_window, COLORS["grey"], rect)
                if self.adjacent_mines > 0:
                    # Show number of adjacent mines
                    font = pygame.font.SysFont('arial', 35)
                    text = font.render(str(self.adjacent_mines), True, COLORS["black"])
                    text_rect = text.get_rect(center=rect.center)
                    game_window.blit(text, text_rect)
        else:
            # Draw unrevealed cell
            pygame.draw.rect(game_window, COLORS["dark_grey"], rect)
            if self.flagged:
                # Show flag on flagged cells
                font = pygame.font.SysFont('arial', 24)
                text = font.render('F', True, COLORS["green"])
                text_rect = text.get_rect(center=rect.center)
                game_window.blit(text, text_rect)
        # Draw border for cell
        pygame.draw.rect(game_window, COLORS["white"], rect, 1)  # Border


class Button:
    def __init__(self, x, y, text):
        self.color = COLORS['grey']
        self.text = text
        self.font = pygame.font.SysFont('arial', 60)
        text_render = self.font.render(self.text, 1, COLORS['green'])
        self.width = text_render.get_width() + 20  # Add some padding to the text width
        self.height = text_render.get_height() + 20  # Add some padding to the text height
        self.x = x - self.width // 2  # Center the button
        self.y = y - self.height // 2  # Center the button

    def draw(self, win, outline=None):
        if outline:
            pygame.draw.rect(win, outline, (self.x - 2, self.y - 2, self.width + 4, self.height + 4), 0)

        pygame.draw.rect(win, self.color, (self.x, self.y, self.width, self.height), 0)

        text_render = self.font.render(self.text, 1, COLORS['green'])
        win.blit(text_render, (
        self.x + (self.width - text_render.get_width()) // 2, self.y + (self.height - text_render.get_height()) // 2))

    def is_over(self, pos):
        if self.x < pos[0] < self.x + self.width:
            if self.y < pos[1] < self.y + self.height:
                return True
        return False

def create_grid():
    grid = [[Cell(x, y) for y in range(GRID_SIZE)] for x in range(GRID_SIZE)]
    mine_locations = set()
    while len(mine_locations) < NUM_MINES:
        mine_locations.add((random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1)))
    for (x, y) in mine_locations:
        grid[x][y].is_mine = True
    for x in range(GRID_SIZE):
        for y in range(GRID_SIZE):
            if not grid[x][y].is_mine:
                grid[x][y].adjacent_mines = sum(1 for dx in (-1, 0, 1) for dy in (-1, 0, 1)
                                               if 0 <= x + dx < GRID_SIZE and 0 <= y + dy < GRID_SIZE
                                               and grid[x + dx][y + dy].is_mine)
    return grid

# Define game_loop function
def main_menu():
    start_btn = Button(WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2, 'Start Game')
    game_window.fill(COLORS['black'])

    while True:
        for event in pygame.event.get():
            pos = pygame.mouse.get_pos()
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.MOUSEBUTTONDOWN:
                if start_btn.is_over(pos):
                    return  # Proceed to game if button is clicked

        start_btn.draw(game_window, COLORS['white'])
        pygame.display.update()
        clock.tick(60)

# Define game_loop function
def game_loop():
    grid = create_grid()  # Initialize the grid with cells and mines
    # Define a variable to control the game loop
    running = True
    # Game Loop
    while running:
        # event handling, gets all event from the event queue
        for event in pygame.event.get():
            # Only do something if the event is of type QUIT
            if event.type == pygame.QUIT:
                # Change the value running to False, to exit the game loop
                running = False
                game_window.fill(COLORS["black"])  # Clear the screen
            elif event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos[0] // CELL_SIZE, event.pos[1] // CELL_SIZE
                if event.button == 1:  # Left click
                    if not grid[x][y].flagged:  # Only reveal if not flagged
                        grid[x][y].revealed = True
                        if grid[x][y].is_mine:
                            print("Game Over!")  # Indicate game over
                            running = False
                elif event.button == 3:  # Right click
                    # Toggle flag on and off
                    grid[x][y].flagged = not grid[x][y].flagged

        game_window.fill(COLORS["black"])  # Clear the screen

        # Draw all cells
        for row in grid:
            for cell in row:
                cell.draw()

        pygame.display.flip()  # Update the full display Surface to the screen
        clock.tick(60)  # Maintain 60 frames per second

# Define main
def main():
    main_menu()  # Show the main menu
    game_loop()  # Start the game loop after exiting the menu

# Start main
main()
pygame.quit()  # Uninitialize all pygame modules
sys.exit()  # Exit the program
